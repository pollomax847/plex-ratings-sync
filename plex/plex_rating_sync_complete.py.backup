#!/home/paulceline/bin/audio/.venv/bin/python
"""
Script complet pour synchroniser les ratings Plex vers les m√©tadonn√©es des fichiers audio
Lit les ratings depuis Plex et les √©crit directement dans les tags ID3/FLAC/MP4
"""

import json
import sys
import argparse
import sqlite3
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from datetime import datetime
import logging

try:
    from mutagen.id3 import ID3
    from mutagen.id3._frames import POPM
    from mutagen.mp3 import MP3
    from mutagen.mp4 import MP4
    from mutagen.flac import FLAC
    from mutagen._file import File
except ImportError:
    print("‚ùå Erreur: Module 'mutagen' requis. Installez avec: pip3 install mutagen")
    sys.exit(1)

class PlexRatingSync:
    def __init__(self, plex_db_path: str, verbose: bool = False):
        self.plex_db_path = Path(plex_db_path)
        self.verbose = verbose
        self.setup_logging()
        self.processed_files = []
        self.failed_files = []
        self.skipped_files = []

    def setup_logging(self):
        log_format = '%(asctime)s - %(levelname)s - %(message)s'
        level = logging.DEBUG if self.verbose else logging.INFO
        logging.basicConfig(
            level=level,
            format=log_format,
            handlers=[logging.StreamHandler(sys.stdout)]
        )
        self.logger = logging.getLogger(__name__)

    def get_plex_ratings(self) -> List[Dict]:
        """R√©cup√®re tous les ratings depuis la base Plex"""
        if not self.plex_db_path.exists():
            raise FileNotFoundError(f"Base Plex introuvable: {self.plex_db_path}")

        ratings = []
        try:
            conn = sqlite3.connect(str(self.plex_db_path))
            cursor = conn.cursor()

            # Requ√™te pour r√©cup√©rer les ratings des pistes audio
            query = """
            SELECT
                m.file,
                m.rating,
                m.view_count,
                m.duration,
                m.title,
                m.album,
                m.artist,
                m.year
            FROM media_items m
            INNER JOIN media_parts mp ON m.id = mp.media_item_id
            WHERE m.rating IS NOT NULL
            AND m.rating > 0
            AND mp.file IS NOT NULL
            ORDER BY m.rating DESC, m.title
            """

            cursor.execute(query)
            rows = cursor.fetchall()

            for row in rows:
                file_path, rating, view_count, duration, title, album, artist, year = row

                # Convertir rating Plex (0-10) vers √©toiles (1-5)
                # Plex utilise 0-10, on convertit en 1-5 √©toiles
                stars_rating = round(rating / 2.0, 1) if rating else None

                if stars_rating and 1 <= stars_rating <= 5:
                    ratings.append({
                        'file_path': file_path,
                        'rating': stars_rating,
                        'play_count': view_count or 0,
                        'duration': duration,
                        'title': title,
                        'album': album,
                        'artist': artist,
                        'year': year,
                        'plex_rating': rating  # Garder l'original pour r√©f√©rence
                    })

            conn.close()

        except sqlite3.Error as e:
            self.logger.error(f"‚ùå Erreur base de donn√©es Plex: {e}")
            raise

        self.logger.info(f"üìä {len(ratings)} fichiers avec ratings trouv√©s dans Plex")
        return ratings

    def rating_to_stars_255(self, rating: float) -> int:
        """Convertit rating 1-5 √©toiles vers valeur 0-255 pour POPM"""
        mapping = {
            1.0: 1,
            2.0: 64,
            3.0: 128,
            4.0: 196,
            5.0: 255
        }
        return mapping.get(rating, 128)

    def set_mp3_rating(self, file_path: Path, rating: float, play_count: Optional[int] = None) -> bool:
        """D√©finit le rating et play count pour fichier MP3"""
        try:
            audio = MP3(file_path, ID3=ID3)

            if audio.tags is None:
                audio.add_tags()

            if audio.tags is not None:
                rating_255 = self.rating_to_stars_255(rating)
                if play_count is not None:
                    audio.tags.add(POPM(email="no@email", rating=rating_255, count=play_count))
                else:
                    audio.tags.add(POPM(email="no@email", rating=rating_255, count=1))

                audio.save()

                log_msg = f"‚úÖ MP3 rating {rating}‚≠ê"
                if play_count is not None:
                    log_msg += f" + {play_count} lectures"
                log_msg += f" √©crit: {file_path.name}"
                self.logger.info(log_msg)
                return True
            else:
                self.logger.error(f"‚ùå Impossible de cr√©er tags ID3: {file_path.name}")
                return False

        except Exception as e:
            self.logger.error(f"‚ùå Erreur MP3 {file_path.name}: {e}")
            return False

    def set_mp4_rating(self, file_path: Path, rating: float, play_count: Optional[int] = None) -> bool:
        """D√©finit le rating et play count pour fichier MP4/M4A"""
        try:
            audio = MP4(file_path)

            rating_100 = int(rating * 20)  # 1‚≠ê=20, 5‚≠ê=100
            audio["----:com.apple.iTunes:rating"] = str(rating_100).encode('utf-8')
            audio["rtng"] = [rating_100]

            if play_count is not None:
                audio["plct"] = [play_count]

            audio.save()

            log_msg = f"‚úÖ MP4 rating {rating}‚≠ê"
            if play_count is not None:
                log_msg += f" + {play_count} lectures"
            log_msg += f" √©crit: {file_path.name}"
            self.logger.info(log_msg)
            return True

        except Exception as e:
            self.logger.error(f"‚ùå Erreur MP4 {file_path.name}: {e}")
            return False

    def set_flac_rating(self, file_path: Path, rating: float, play_count: Optional[int] = None) -> bool:
        """D√©finit le rating et play count pour fichier FLAC"""
        try:
            audio = FLAC(file_path)

            rating_100 = str(int(rating * 20))
            audio["RATING"] = rating_100
            rating_decimal = str(rating / 5.0)
            audio["FMPS_RATING"] = rating_decimal

            if play_count is not None:
                audio["PLAYCOUNT"] = str(play_count)

            audio.save()

            log_msg = f"‚úÖ FLAC rating {rating}‚≠ê"
            if play_count is not None:
                log_msg += f" + {play_count} lectures"
            log_msg += f" √©crit: {file_path.name}"
            self.logger.info(log_msg)
            return True

        except Exception as e:
            self.logger.error(f"‚ùå Erreur FLAC {file_path.name}: {e}")
            return False

    def sync_file_rating(self, file_info: Dict) -> bool:
        """Synchronise le rating d'un fichier vers ses m√©tadonn√©es"""
        file_path = Path(file_info['file_path'])
        rating = float(file_info['rating'])
        play_count = file_info.get('play_count')

        if not file_path.exists():
            self.logger.warning(f"‚ùå Fichier introuvable: {file_path}")
            self.skipped_files.append(file_info)
            return False

        suffix = file_path.suffix.lower()

        success = False
        if suffix in ['.mp3']:
            success = self.set_mp3_rating(file_path, rating, play_count)
        elif suffix in ['.mp4', '.m4a', '.aac']:
            success = self.set_mp4_rating(file_path, rating, play_count)
        elif suffix in ['.flac']:
            success = self.set_flac_rating(file_path, rating, play_count)
        else:
            self.logger.warning(f"‚ö†Ô∏è Format non support√©: {suffix} - {file_path.name}")
            self.skipped_files.append(file_info)
            return False

        if success:
            self.processed_files.append(file_info)
        else:
            self.failed_files.append(file_info)

        return success

    def save_ratings_json(self, ratings: List[Dict], output_file: Path):
        """Sauvegarde les ratings dans un fichier JSON"""
        data = {
            'export_date': datetime.now().isoformat(),
            'total_ratings': len(ratings),
            'ratings': ratings
        }

        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        self.logger.info(f"üíæ Ratings sauvegard√©s: {output_file}")

    def show_statistics(self, ratings: List[Dict]):
        """Affiche les statistiques des ratings"""
        if not ratings:
            self.logger.warning("Aucun rating trouv√©")
            return

        rating_counts = {}
        for item in ratings:
            rating = item['rating']
            rating_counts[rating] = rating_counts.get(rating, 0) + 1

        print("\nüìä STATISTIQUES DES RATINGS PLEX:")
        print("=" * 50)
        for rating in sorted(rating_counts.keys()):
            stars = "‚≠ê" * int(rating)
            print(f"{stars} ({rating}) : {rating_counts[rating]} fichiers")

        print(f"\nTotal: {len(ratings)} fichiers avec ratings")

    def sync_all_ratings(self, dry_run: bool = False) -> Dict:
        """Synchronise tous les ratings de Plex vers les fichiers"""
        try:
            # R√©cup√©rer les ratings depuis Plex
            ratings = self.get_plex_ratings()

            if not ratings:
                return {'success': False, 'error': 'Aucun rating trouv√© dans Plex'}

            # Statistiques
            self.show_statistics(ratings)

            if dry_run:
                self.logger.info("üîç Mode simulation - aucun fichier ne sera modifi√©")
                return {
                    'success': True,
                    'dry_run': True,
                    'total_ratings': len(ratings)
                }

            # Synchroniser chaque fichier
            self.logger.info(f"üéµ Synchronisation ratings pour {len(ratings)} fichiers...")

            for file_info in ratings:
                self.sync_file_rating(file_info)

            # R√©sultats
            stats = {
                'success': True,
                'total_ratings': len(ratings),
                'processed': len(self.processed_files),
                'failed': len(self.failed_files),
                'skipped': len(self.skipped_files)
            }

            self.logger.info("‚úÖ Synchronisation termin√©e:")
            self.logger.info(f"   üìä Total ratings: {stats['total_ratings']}")
            self.logger.info(f"   ‚úÖ Trait√©s: {stats['processed']}")
            self.logger.info(f"   ‚ùå √âchecs: {stats['failed']}")
            self.logger.info(f"   ‚ö†Ô∏è Ignor√©s: {stats['skipped']}")

            return stats

        except Exception as e:
            self.logger.error(f"‚ùå Erreur synchronisation: {e}")
            return {'success': False, 'error': str(e)}

def find_plex_database():
    """Trouve automatiquement la base de donn√©es Plex"""
    possible_paths = [
        Path("/var/snap/plexmediaserver/common/Library/Application Support/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db"),
        Path.home() / ".config/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db",
        Path("/var/lib/plexmediaserver/Library/Application Support/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db"),
        Path.home() / "Library/Application Support/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db",
        Path.home() / "AppData/Local/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db"
    ]

    for path in possible_paths:
        if path.exists():
            return str(path)

    return None

def main():
    parser = argparse.ArgumentParser(
        description='Synchronise les ratings Plex vers les m√©tadonn√©es des fichiers audio',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples:
    # Simulation (recommand√© d'abord)
    python3 plex_rating_sync_complete.py --plex-db /path/to/plex.db --dry-run

    # Synchronisation r√©elle
    python3 plex_rating_sync_complete.py --plex-db /path/to/plex.db

    # Avec recherche automatique de la base Plex
    python3 plex_rating_sync_complete.py --auto-find-db

    # Sauvegarder les ratings dans un JSON sans synchroniser
    python3 plex_rating_sync_complete.py --plex-db /path/to/plex.db --export-only ratings.json

    # Statistiques seulement
    python3 plex_rating_sync_complete.py --plex-db /path/to/plex.db --stats
        """
    )
    
    parser.add_argument(
        '--plex-db', '--plex-database',
        type=str,
        help='Chemin vers la base de donn√©es Plex'
    )
    
    parser.add_argument(
        '--auto-find-db',
        action='store_true',
        help='Recherche automatiquement la base Plex'
    )
    
    parser.add_argument(
        '--dry-run', '--simulate',
        action='store_true',
        help='Mode simulation (aucun fichier modifi√©)'
    )
    
    parser.add_argument(
        '--stats', '--statistics',
        action='store_true',
        help='Affiche les statistiques et quitte'
    )
    
    parser.add_argument(
        '--export-only',
        type=str,
        help='Exporte les ratings vers JSON sans synchroniser'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Mode verbeux'
    )
    
    args = parser.parse_args()

    # D√©terminer le chemin de la base Plex
    plex_db_path = args.plex_db

    if args.auto_find_db or not plex_db_path:
        auto_path = find_plex_database()
        if auto_path:
            plex_db_path = auto_path
            print(f"üîç Base Plex trouv√©e automatiquement: {plex_db_path}")
        elif not plex_db_path:
            print("‚ùå Base de donn√©es Plex introuvable.")
            print("Utilisez --plex-db pour sp√©cifier le chemin manuellement.")
            sys.exit(1)

    # Initialiser le synchroniseur
    try:
        syncer = PlexRatingSync(plex_db_path, verbose=args.verbose)

        # Mode export seulement
        if args.export_only:
            ratings = syncer.get_plex_ratings()
            syncer.save_ratings_json(ratings, Path(args.export_only))
            return

        # Mode statistiques
        if args.stats:
            ratings = syncer.get_plex_ratings()
            syncer.show_statistics(ratings)
            return

        # Synchronisation
        result = syncer.sync_all_ratings(dry_run=args.dry_run)

        if not result['success']:
            print(f"‚ùå Erreur: {result.get('error', 'Erreur inconnue')}")
            sys.exit(1)

        # Message de succ√®s si mode r√©el
        if not args.dry_run:
            print("\n‚úÖ Synchronisation termin√©e avec succ√®s!")
            print("Les ratings Plex ont √©t√© √©crits dans les m√©tadonn√©es des fichiers audio.")
            print("Vous pouvez maintenant voir les √©toiles dans vos lecteurs audio!")

    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Op√©ration interrompue par l'utilisateur")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Erreur inattendue: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()</content>
<parameter name="filePath">/home/paulceline/bin/audio/plex_rating_sync_complete.py